import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Date;

public class ServerMessageThread extends Thread{
	Client client;
	private InputStream is;
	private OutputStream os;
	private MessageManager messageManager;
	
	private boolean running;
	private Socket messageSocket;
	
	public ServerMessageThread(Socket messageSocket) {
		super();
		this.messageSocket = messageSocket;
		this.running = true;
		this.client = new Client();
		
		try {
			this.is = this.messageSocket.getInputStream();
			this.os = this.messageSocket.getOutputStream();
			
			messageManager = new MessageManager(new ObjectInputStream(this.is), new ObjectOutputStream(this.os));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void run() {
		while(isRunning()) {
			Message message = getMessageManager().readMessage();
			
			if(message == null) {
				break;
			}
			
			else if(message.getType() == Message.TYPE_UPDATECLIENT) {
				String tempName = this.client.getName();
				System.out.println(this.client.getName());
				
				this.client = message.getUpdate();
				
				if(tempName.equals("")) {
					this.client.setId(MainServer.getNewID());
					Message msgUpdate = new Message(this.client, Message.TYPE_UPDATECLIENT);
					getMessageManager().sendMessage(msgUpdate);
					
					for(Message msg : MainServer.messageHistoric) {
						if(msg.hasReceiver()) {
							if(this.getClient().getId() == msg.getReceiver().getId()) {
								getMessageManager().sendMessage(message);
								break;
							}
						}
						else {
							getMessageManager().sendMessage(msg);
						}
					}
					
					Date date = new Date();
					Message msgConnect = new Message("Client connected (" + client.getName() + "). ID: " + client.getId() + "!", Message.TYPE_PLAINTEXT, date);
					MainServer.jtaChat.append("[" + msgConnect.getFormattedServerDate() + "] " + msgConnect.getMessage() + "!\n");
					MainServer.messageHistoric.add(msgConnect);
					
					ArrayList<Client> clients = new ArrayList<Client>();
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						clients.add(tc.getClient());
					}
					
					Message updateUsers = new Message(clients, Message.TYPE_UPDATEUSERS);
					
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						tc.getMessageManager().sendMessage(msgConnect);
						tc.getMessageManager().sendMessage(updateUsers);
					}
				}
				else if(!tempName.equals(this.client.getName())) {
					Date date = new Date();
					Message msg = new Message(tempName + " has changed his name to " + this.client.getName() + "!", Message.TYPE_PLAINTEXT, date);
					MainServer.jtaChat.append("[" + msg.getFormattedServerDate() + "] " + msg.getMessage() + "\n");
					MainServer.messageHistoric.add(msg);
					
					ArrayList<Client> clients = new ArrayList<Client>();
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						clients.add(tc.getClient());
					}
					
					Message updateUsers = new Message(clients, Message.TYPE_UPDATEUSERS);
					
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						tc.getMessageManager().sendMessage(msg);
						tc.getMessageManager().sendMessage(updateUsers);
					}
					
				}
			}
			else if(message.getType() == Message.TYPE_PLAINTEXT) {
				message.setServerDate(new Date());
				
				MainServer.messageHistoric.add(message);
				
				if(message.hasReceiver()) {
					MainServer.jtaChat.append("["+ message.getFormattedServerDate() + "] " + message.getSender().getName() + "(ID: " + message.getSender().getId() + ") TO " + message.getReceiver().getName() + "(ID: " + message.getReceiver().getId() + ") >> " + message.getMessage() + "\n");
					
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						if(tc.getClient().getId() == message.getReceiver().getId() || tc.getClient().getId() == message.getSender().getId()) {
							tc.getMessageManager().sendMessage(message);
						}
					}
				}
				else {
					MainServer.jtaChat.append("["+ message.getFormattedServerDate() + "] " + message.getSender().getName() + "(ID: " + message.getSender().getId() + ") >> " + message.getMessage() + "\n");
					
					for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
						tc.getMessageManager().sendMessage(message);
					}
				}
				
				
			}
			else if(message.getType() == Message.TYPE_FILE) {
				//TODO Pegar a thread de arquivo do cliente sender e fazer ela reenviar para as pessoas certas
				//TODO O download qd o sender mando é automatico, reconhecer arquivo enviado pela ID e filename
			}
			
			
		}
	}
	
	public void disconnect() {
		setRunning(true);
		
		try {
			getMessageManager().close();
			messageSocket.close();
		} catch (IOException e2) {
			e2.printStackTrace();
		}
		
		MainServer.getConnectedMessageThreads().remove(this);
		Date date = new Date();
		Message msg = new Message("Client " + client.getName() + " [ID:" + client.getId() + "] disconnected!", Message.TYPE_PLAINTEXT, date);
		MainServer.jtaChat.append("[" + msg.getFormattedServerDate() + "] " + msg.getMessage() + "!\n");
		MainServer.messageHistoric.add(msg);
		
		ArrayList<Client> clients = new ArrayList<Client>();
		for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
			clients.add(tc.getClient());
		}
		
		Message updateUsers = new Message(clients, Message.TYPE_UPDATEUSERS);
		
		for(ServerMessageThread tc: MainServer.getConnectedMessageThreads()) {
			tc.getMessageManager().sendMessage(msg);
			tc.getMessageManager().sendMessage(updateUsers);
		}
	}
	

	
	
	
	public MessageManager getMessageManager() {
		return messageManager;
	}

	public void setMessageManager(MessageManager messageManager) {
		this.messageManager = messageManager;
	}

	public Client getClient() {
		return client;
	}

	public void setClient(Client client) {
		this.client = client;
	}

	public boolean isRunning() {
		return running;
	}

	public void setRunning(boolean running) {
		this.running = running;
	}
	
	
	
}
